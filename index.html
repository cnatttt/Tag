<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2PlayerTag</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0d0782; font-family: system-ui, Arial; }
    .wrap { height: 100%; display:flex; align-items:center; justify-content:center; }
    canvas { background:#0d0782; border:2px solid #ffd400; image-rendering: pixelated; }

    .ui {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(circle at 50% 20%, rgba(255,212,0,.18), rgba(0,0,0,.65));
    }
    .card {
      width: min(560px, 92vw);
      background: rgba(10,10,25,.92);
      border: 2px solid rgba(255,212,0,.35);
      border-radius: 18px;
      padding: 20px;
      color: #fff;
      box-shadow: 0 22px 70px rgba(0,0,0,.55);
      position: relative;
      overflow: hidden;
    }
    .glow {
      position:absolute; inset:-40px;
      background: conic-gradient(from 180deg, rgba(0,180,255,.0), rgba(0,180,255,.25), rgba(255,212,0,.2), rgba(0,180,255,.0));
      filter: blur(30px);
      opacity: .55;
      animation: spin 6s linear infinite;
      pointer-events:none;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .title { font-size: 26px; font-weight: 900; margin: 0 0 4px; letter-spacing: .4px; }
    .dev { opacity:.9; margin: 0 0 14px; font-weight: 700; }
    .sub { opacity: .85; margin: 0 0 14px; line-height: 1.35; }

    .row { display:flex; gap: 12px; flex-wrap: wrap; align-items:center; }
    button {
      cursor:pointer;
      border: 2px solid rgba(0,180,255,.35);
      background: rgba(18,18,50,.9);
      color:#fff;
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 800;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
    }
    button:hover { background: rgba(25,25,70,.95); border-color: rgba(255,212,0,.5); }
    button:active { transform: translateY(1px); }

    .sliderBox, .modeBox{
      flex: 1 1 220px;
      border: 2px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(255,255,255,.04);
    }
    .sliderBox label, .modeBox label { display:flex; justify-content:space-between; font-weight:800; opacity:.95; }
    input[type="range"] { width: 100%; margin-top: 8px; }
    .modeBox label { margin-bottom: 6px; }
    select{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:2px solid rgba(0,180,255,.25);
      background: rgba(18,18,50,.9);
      color:#fff;
      font-weight:800;
      outline:none;
    }

    .hint { margin-top: 14px; opacity:.9; font-size: 13px; line-height:1.45; }
    kbd { background:#111; border:1px solid #333; border-bottom-width:2px; padding:2px 6px; border-radius:6px; }
    .tip {
      margin-top: 10px;
      font-size: 12px;
      opacity: .85;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,212,0,.25);
      background: rgba(255,212,0,.06);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="800" height="800"></canvas>
  </div>

  <div class="ui" id="menu">
    <div class="card">
      <div class="glow"></div>

      <p class="title">2PlayerTag</p>
      <p class="dev">Dev: Mcant</p>
      <p class="sub">
        Tagger is slightly faster + small reach buff.
        <br/>Classic: survive <b>20 seconds</b> as runner to score ‚Äî <b>first to 10</b> wins.
        <br/>Longest Run: each player gets 1 runner turn; longest runner time wins.
        <br/>Symmetrical random map each round (4 maps). Middle reachable on all.
      </p>

      <div class="row">
        <button id="play">PLAY</button>
        <button id="resetScore">RESET SCORE</button>

        <div class="modeBox">
          <label>
            <span>Game Mode</span>
            <span id="modeLabel">Classic</span>
          </label>
          <select id="mode">
            <option value="classic" selected>Classic (First to 10)</option>
            <option value="longest">Longest Run (2 rounds)</option>
          </select>
        </div>

        <div class="sliderBox">
          <label>
            <span>Volume</span>
            <span id="volLabel">70%</span>
          </label>
          <input id="vol" type="range" min="0" max="100" value="70" />
        </div>
      </div>

      <div class="hint">
        <div><b>Player 1 (top-left):</b> <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></div>
        <div><b>Player 2 (bottom-right):</b> Arrow Keys</div>
        <div style="margin-top:8px;">Press <b>Esc</b> to go back to the menu.</div>
      </div>

      <div class="tip" id="tipBox">Tip: (loads when you open the menu)</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("c");
    const g = canvas.getContext("2d");

    const menu = document.getElementById("menu");
    const playBtn = document.getElementById("play");
    const resetScoreBtn = document.getElementById("resetScore");
    const vol = document.getElementById("vol");
    const volLabel = document.getElementById("volLabel");
    const tipBox = document.getElementById("tipBox");

    const modeSel = document.getElementById("mode");
    const modeLabel = document.getElementById("modeLabel");

    const W = canvas.width, H = canvas.height;

    // ========= AUDIO (beeps + 8-bit background music) =========
    let volume = 0.70;
    let audioReady = false;
    let audioCtx = null;
    let musicGain = null;
    let musicTimer = null;
    let musicStep = 0;

    function ensureAudio(){
      if(audioReady) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if(!AudioCtx) return;
      audioCtx = new AudioCtx();
      musicGain = audioCtx.createGain();
      musicGain.gain.value = Math.max(0.0001, volume * 0.05);
      musicGain.connect(audioCtx.destination);
      audioReady = true;
      startMusic();
    }

    // call ensureAudio on any user interaction (browser policy)
    window.addEventListener("pointerdown", ensureAudio, {once:false});
    window.addEventListener("keydown", ensureAudio, {once:false});

    vol.addEventListener("input", () => {
      volume = Number(vol.value) / 100;
      volLabel.textContent = Math.round(volume * 100) + "%";
      if(musicGain) musicGain.gain.value = Math.max(0.0001, volume * 0.05);
      beep(660, 0.03);
    });

    function beep(freq=440, dur=0.04){
      if(volume <= 0) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if(!AudioCtx) return;
      if(!audioCtx){
        // lazy init for beeps too
        audioCtx = new AudioCtx();
      }
      const o = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      gain.gain.value = Math.max(0.0001, volume * 0.08);
      o.frequency.value = freq;
      o.type = "square";
      o.connect(gain);
      gain.connect(audioCtx.destination);
      o.start();
      o.stop(audioCtx.currentTime + dur);
    }

    function playNote(freq, dur=0.12){
      if(!audioReady || !audioCtx || !musicGain) return;
      const t = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const eg = audioCtx.createGain();
      o.type = "square";
      o.frequency.setValueAtTime(freq, t);

      // simple envelope
      eg.gain.setValueAtTime(0.0001, t);
      eg.gain.linearRampToValueAtTime(0.25, t + 0.01);
      eg.gain.exponentialRampToValueAtTime(0.0001, t + dur);

      o.connect(eg);
      eg.connect(musicGain);
      o.start(t);
      o.stop(t + dur + 0.02);
    }

    function hzFromMidi(m){
      return 440 * Math.pow(2, (m - 69) / 12);
    }

    function startMusic(){
      if(musicTimer) return;
      // simple looping chiptune: bass + lead, 140 bpm-ish
      const stepMs = 120; // ~8th/16th vibe
      const bass = [36,36,43,43,41,41,38,38, 36,36,43,43,41,41,38,38];
      const lead = [60,62,64,67, 64,62,60,62, 64,67,69,67, 64,62,60,57];
      musicStep = 0;

      musicTimer = setInterval(() => {
        // keep it running even in menu; volume slider controls everything
        const b = bass[musicStep % bass.length];
        const l = lead[musicStep % lead.length];

        // bass on even steps, lead on all steps
        if((musicStep % 2) === 0) playNote(hzFromMidi(b), 0.14);
        playNote(hzFromMidi(l), 0.10);

        musicStep++;
      }, stepMs);
    }

    // ========= UI =========
    modeSel.addEventListener("change", ()=>{
      modeLabel.textContent = (modeSel.value === "classic") ? "Classic" : "Longest Run";
      beep(520, 0.03);
    });

    // ========= MAPS (symmetrical + middle reachable) =========
    function mirrorX(rects){
      const out = rects.slice();
      for(const r of rects){
        out.push({ x: (W - (r.x + r.w)), y: r.y, w: r.w, h: r.h });
      }
      return out;
    }

    // Build maps from LEFT-HALF pieces + mirror (perfect symmetry)
    const MAPS = [
      // MAP 1: "Open pillars + side bumpers"
      (() => {
        const L = [
          // outer frame broken into segments (entrances)
          {x:120,y:120,w:240,h:20},
          {x:120,y:660,w:240,h:20},
          {x:120,y:120,w:20,h:200},
          {x:120,y:500,w:20,h:180},

          // side bumpers
          {x:70,y:260,w:90,h:20},
          {x:70,y:520,w:90,h:20},

          // pillar grid left half
          {x:260,y:240,w:35,h:35},
          {x:260,y:360,w:35,h:35},
          {x:260,y:480,w:35,h:35},

          {x:340,y:300,w:30,h:30},
          {x:340,y:450,w:30,h:30},

          // lanes to center (don‚Äôt block)
          {x:360,y:390,w:60,h:20}, // approaches mid
        ];
        const center = [
          // tiny center posts (still allows all-direction entry)
          {x:395,y:300,w:10,h:200},
          {x:370,y:390,w:60,h:20},
        ];
        return mirrorX(L).concat(center);
      })(),

      // MAP 2: "S-lanes / corridor dance"
      (() => {
        const L = [
          // top/bottom segments with gaps
          {x:140,y:150,w:240,h:20},
          {x:140,y:630,w:240,h:20},

          // left posts split (entrances)
          {x:140,y:150,w:20,h:170},
          {x:140,y:480,w:20,h:170},

          // inner S walls (left half)
          {x:260,y:260,w:160,h:20},
          {x:260,y:520,w:160,h:20},
          {x:260,y:280,w:20,h:240},

          // mid connector from left into center
          {x:320,y:390,w:80,h:20},
          {x:360,y:320,w:20,h:140},

          // side bumper
          {x:70,y:390,w:100,h:20},
        ];
        const center = [
          // keep center open but give structure
          {x:400,y:280,w:20,h:240},
          {x:380,y:390,w:40,h:20},
        ];
        return mirrorX(L).concat(center);
      })(),

      // MAP 3: "Two rooms + triple bridges (always can reach mid)"
      (() => {
        const L = [
          // left room boundaries (broken)
          {x:110,y:140,w:20,h:220},
          {x:110,y:500,w:20,h:200},
          {x:110,y:140,w:260,h:20},
          {x:110,y:680,w:260,h:20},

          // inner wall chunks (leave doors)
          {x:330,y:140,w:20,h:130},
          {x:330,y:350,w:20,h:110},
          {x:330,y:540,w:20,h:160},

          // bridges into center (top/mid/bot)
          {x:350,y:240,w:90,h:20},
          {x:350,y:390,w:90,h:20},
          {x:350,y:540,w:90,h:20},

          // jukes
          {x:200,y:300,w:70,h:20},
          {x:200,y:500,w:70,h:20},
        ];
        const center = [
          // center thin rails (still passable around them)
          {x:395,y:220,w:10,h:360},
          {x:370,y:390,w:60,h:20},
        ];
        return mirrorX(L).concat(center);
      })(),

      // MAP 4: "Diamond mid + multi-entrance ring"
      (() => {
        const L = [
          // outer broken ring
          {x:130,y:120,w:250,h:20},
          {x:130,y:660,w:250,h:20},
          {x:130,y:120,w:20,h:210},
          {x:130,y:470,w:20,h:210},

          // diagonal-ish blockers (rectangles) to create lanes
          {x:220,y:220,w:140,h:20},
          {x:220,y:560,w:140,h:20},
          {x:220,y:240,w:20,h:140},
          {x:220,y:420,w:20,h:140},

          // side bumpers (wide lanes)
          {x:70,y:300,w:110,h:20},
          {x:70,y:500,w:110,h:20},

          // approach to center from multiple angles
          {x:340,y:330,w:60,h:20},
          {x:340,y:450,w:60,h:20},
        ];
        const center = [
          // ‚Äúdiamond‚Äù made of 4 small posts (center still enterable from N/E/S/W)
          {x:385,y:340,w:30,h:30},
          {x:385,y:430,w:30,h:30},
          {x:340,y:385,w:30,h:30},
          {x:430,y:385,w:30,h:30},
        ];
        return mirrorX(L).concat(center);
      })(),
    ];

    let obs = MAPS[0];
    let lastMap = -1;

    function pickRandomMap(){
      let idx = Math.floor(Math.random() * MAPS.length);
      if(MAPS.length > 1 && idx === lastMap) idx = (idx + 1) % MAPS.length;
      lastMap = idx;
      obs = MAPS[idx];
    }

    // ========= COLLISION / MOVE =========
    function rectsIntersect(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }
    function rectIntersectsAny(r){
      for(const o of obs){
        if(rectsIntersect(r, o)) return true;
      }
      return false;
    }
    function tryMove(x, y, dx, dy, size){
      let nx = x, ny = y;

      nx += dx;
      let testX = {x:nx, y:y, w:size, h:size};
      if(rectIntersectsAny(testX)) nx = x;

      ny += dy;
      let testY = {x:nx, y:ny, w:size, h:size};
      if(rectIntersectsAny(testY)) ny = y;

      nx = Math.max(0, Math.min(W - size, nx));
      ny = Math.max(0, Math.min(H - size, ny));
      return {x:nx, y:ny};
    }
    function slideMove(p, dx, dy, size){
      const nxt = tryMove(p.x, p.y, dx, dy, size);
      p.x = nxt.x; p.y = nxt.y;
    }

    // ========= GAME STATE =========
    const base = 20;
    const big  = base + 10;

    const p1 = { x:30,  y:30,  score:0 }; // WASD
    const p2 = { x:740, y:740, score:0 }; // Arrows

    let count = 0; // role swap counter
    const SPEED = 8;
    const TAG_SPEED = SPEED + 1;
    const TAG_REACH = 4;

    const ROUND_SECONDS = 20;
    let timeLeft = ROUND_SECONDS;

    const WIN_POINTS = 10;

    let running = false;

    // Longest Run
    let mode = "classic";
    let lrPhase = 0;    // 1 then 2 then done
    let lrP1Best = 0;   // seconds
    let lrP2Best = 0;   // seconds

    const keys = new Set();
    window.addEventListener("keydown", (e)=>{
      if(e.key === "Escape"){ openMenu(); }
      keys.add(e.key.toLowerCase());
      if(["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key.toLowerCase())) e.preventDefault();
    }, {passive:false});
    window.addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()));

    function isP1Tagger(){ return (count % 2 === 1); }
    function sizeForP1(){ return isP1Tagger() ? big : base; }
    function sizeForP2(){ return isP1Tagger() ? base : big; }

    function forceRoles(p1Tagger){
      count = p1Tagger ? 1 : 0;
    }

    function loadTip(){
      const tips = [
        "Tip: Tagger wins by cutting corners, not chasing behind.",
        "Tip: Runner: don‚Äôt hug borders‚Äîuse mid lanes to juke.",
        "Tip: Random symmetrical maps‚Äîlearn the center entries fast.",
        "Tip: In Longest Run, play safe early, risky late.",
        "Tip: Slide along obstacles instead of stopping when boxed.",
      ];
      tipBox.textContent = tips[Math.floor(Math.random()*tips.length)];
    }

    function openMenu(){
      running = false;
      menu.style.display = "flex";
      keys.clear();

      // reset Longest Run session state (scores stay unless you hit reset)
      lrPhase = 0;
      lrP1Best = 0;
      lrP2Best = 0;

      loadTip();
      beep(440, 0.03); setTimeout(()=>beep(660, 0.03), 70);
    }

    function startGame(){
      ensureAudio();
      mode = modeSel.value;
      running = true;
      menu.style.display = "none";

      if(mode === "classic"){
        // start fresh match (keeps scores if you didn't reset? most games reset match scores)
        p1.score = 0; p2.score = 0;
        count = 0;
        startRound(false); // no swap on match start
      } else {
        startLongestRun();
      }

      beep(880, 0.04);
    }

    // IMPORTANT: map only changes AFTER a round ends (this function is called only between rounds)
    function startRound(swapRoles=true){
      pickRandomMap();
      p1.x = 30;  p1.y = 30;
      p2.x = 740; p2.y = 740;
      if(swapRoles) count++;
      timeLeft = ROUND_SECONDS;
    }

    function startLongestRun(){
      lrPhase = 1;
      lrP1Best = 0;
      lrP2Best = 0;

      // Phase 1: P1 runner, P2 tagger
      forceRoles(false); // P2 tagger
      startRound(false);
    }

    function endClassicMatchAndReturn(){
      const winner = (p1.score > p2.score) ? "P1" : "P2";
      openMenu();
      tipBox.textContent = `üèÜ ${winner} WINS the Classic match! Final: P1 ${p1.score} - P2 ${p2.score}`;
      beep(660, 0.05); setTimeout(()=>beep(880, 0.05), 70);
    }

    function endLongestRunAndReturn(){
      const p1Sec = lrP1Best.toFixed(2);
      const p2Sec = lrP2Best.toFixed(2);

      let msg = "";
      if(lrP1Best > lrP2Best) msg = `P1 WINS!  P1: ${p1Sec}s  |  P2: ${p2Sec}s`;
      else if(lrP2Best > lrP1Best) msg = `P2 WINS!  P1: ${p1Sec}s  |  P2: ${p2Sec}s`;
      else msg = `TIE!  P1: ${p1Sec}s  |  P2: ${p2Sec}s`;

      openMenu();
      tipBox.textContent = "üèÅ Longest Run Results: " + msg;
      beep(660, 0.05); setTimeout(()=>beep(880, 0.05), 70);
    }

    playBtn.onclick = startGame;

    resetScoreBtn.onclick = ()=>{
      p1.score = 0; p2.score = 0;
      beep(330, 0.04);
      setTimeout(()=>beep(220, 0.04), 60);
      tipBox.textContent = "Scores reset.";
    };

    // Surprise
    let shakeTicks = 0;
    window.addEventListener("keydown", (e)=>{
      if(!running && e.key.toLowerCase() === "m"){
        tipBox.textContent = "üëÄ Secret found: Mcant Mode unlocked (it does nothing... yet).";
        beep(990, 0.05); setTimeout(()=>beep(1320, 0.05), 70);
      }
    });

    // ========= GAME LOOP (real seconds, not fake ‚Äú50 fps‚Äù) =========
    let lastT = performance.now();

    function step(t){
      const dt = Math.min(0.05, (t - lastT) / 1000); // clamp for tab-switch spikes
      lastT = t;

      update(dt);
      draw();

      requestAnimationFrame(step);
    }

    function update(dt){
      if(!running) return;

      const p1Tag = isP1Tagger();
      const p1Size = sizeForP1();
      const p2Size = sizeForP2();

      const p1Speed = (p1Tag ? TAG_SPEED : SPEED);
      const p2Speed = (p1Tag ? SPEED : TAG_SPEED);

      // P1 (WASD)
      let p1dx = 0, p1dy = 0;
      if(keys.has("w")) p1dy -= p1Speed;
      if(keys.has("s")) p1dy += p1Speed;
      if(keys.has("a")) p1dx -= p1Speed;
      if(keys.has("d")) p1dx += p1Speed;
      slideMove(p1, p1dx, p1dy, p1Size);

      // P2 (Arrows)
      let p2dx = 0, p2dy = 0;
      if(keys.has("arrowup")) p2dy -= p2Speed;
      if(keys.has("arrowdown")) p2dy += p2Speed;
      if(keys.has("arrowleft")) p2dx -= p2Speed;
      if(keys.has("arrowright")) p2dx += p2Speed;
      slideMove(p2, p2dx, p2dy, p2Size);

      // timer
      timeLeft = Math.max(0, timeLeft - dt);

      // tag check with reach buff
      let hb1 = {x:p1.x, y:p1.y, w:p1Size, h:p1Size};
      let hb2 = {x:p2.x, y:p2.y, w:p2Size, h:p2Size};

      if(p1Tag){
        hb1 = {x:hb1.x - TAG_REACH, y:hb1.y - TAG_REACH, w:hb1.w + TAG_REACH*2, h:hb1.h + TAG_REACH*2};
      } else {
        hb2 = {x:hb2.x - TAG_REACH, y:hb2.y - TAG_REACH, w:hb2.w + TAG_REACH*2, h:hb2.h + TAG_REACH*2};
      }

      const tagged = rectsIntersect(hb1, hb2);
      const timeUp = (timeLeft <= 0);

      if(mode === "classic"){
        if(tagged){
          if(p1Tag) p1.score++; else p2.score++;
          shakeTicks = 14;
          beep(220, 0.05); setTimeout(()=>beep(110, 0.06), 70);

          if(p1.score >= WIN_POINTS || p2.score >= WIN_POINTS){
            endClassicMatchAndReturn();
            return;
          }
          startRound(true); // round ended -> now map switches
        } else if(timeUp){
          // runner scores for surviving
          if(p1Tag) p2.score++; else p1.score++;
          beep(660, 0.04); setTimeout(()=>beep(880, 0.04), 60);

          if(p1.score >= WIN_POINTS || p2.score >= WIN_POINTS){
            endClassicMatchAndReturn();
            return;
          }
          startRound(true); // round ended -> now map switches
        }
      } else {
        // Longest Run: each phase is a round; time survived is (ROUND_SECONDS - timeLeft)
        const survived = (ROUND_SECONDS - timeLeft);

        // Phase 1: P1 runner (P2 tagger)
        if(lrPhase === 1 && !p1Tag){
          lrP1Best = Math.max(lrP1Best, Math.min(ROUND_SECONDS, survived));
        }
        // Phase 2: P2 runner (P1 tagger)
        if(lrPhase === 2 && p1Tag){
          lrP2Best = Math.max(lrP2Best, Math.min(ROUND_SECONDS, survived));
        }

        if(tagged || timeUp){
          shakeTicks = 14;
          beep(220, 0.05); setTimeout(()=>beep(110, 0.06), 70);

          if(lrPhase === 1){
            lrPhase = 2;
            forceRoles(true);    // P1 tagger, P2 runner
            startRound(false);   // round ended -> now map switches
          } else if(lrPhase === 2){
            lrPhase = 3;
            endLongestRunAndReturn();
          }
        }
      }
    }

    function draw(){
      let sx = 0, sy = 0;
      if(shakeTicks > 0){
        shakeTicks--;
        sx = (Math.random()*8 - 4);
        sy = (Math.random()*8 - 4);
      }

      g.setTransform(1,0,0,1,0,0);
      g.clearRect(0,0,W,H);
      g.setTransform(1,0,0,1,sx,sy);

      // background grid
      g.strokeStyle = "rgb(25,25,25)";
      for(let x=0;x<W;x+=40){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke(); }
      for(let y=0;y<H;y+=40){ g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.stroke(); }

      // obstacles
      g.fillStyle = "rgb(0,180,255)";
      g.strokeStyle = "white";
      for(const r of obs){
        g.fillRect(r.x,r.y,r.w,r.h);
        g.strokeRect(r.x,r.y,r.w,r.h);
      }

      // players
      const p1Tag = isP1Tagger();
      const p1Size = sizeForP1();
      const p2Size = sizeForP2();

      g.fillStyle = p1Tag ? "red" : "white";
      g.fillRect(p1.x, p1.y, p1Size, p1Size);

      g.fillStyle = p1Tag ? "white" : "red";
      g.fillRect(p2.x, p2.y, p2Size, p2Size);

      // border
      g.strokeStyle = "#ffd400";
      g.strokeRect(0.5,0.5,W-1,H-1);

      // UI text
      g.fillStyle = "white";
      g.font = "16px system-ui, Arial";
      g.fillText(`P1: ${p1.score}`, 14, 22);
      g.fillText(`TIME: ${Math.ceil(timeLeft)}`, (W/2)-38, 22);
      g.fillText(`P2: ${p2.score}`, W-70, 22);

      g.font = "14px system-ui, Arial";
      g.fillText(p1Tag ? "TAGGER" : "RUNNER", 14, 44);
      g.fillText(p1Tag ? "RUNNER" : "TAGGER", W-82, 44);

      if(mode === "classic"){
        g.font = "13px system-ui, Arial";
        g.fillText(`Classic ‚Ä¢ First to ${WIN_POINTS}`, (W/2)-70, 44);
      } else {
        g.font = "13px system-ui, Arial";
        g.fillText(`Longest Run`, (W/2)-45, 44);
        g.fillText(`P1 best: ${lrP1Best.toFixed(2)}s`, 14, 62);
        g.fillText(`P2 best: ${lrP2Best.toFixed(2)}s`, W-150, 62);
        g.fillText(`Round: ${Math.min(lrPhase,2)}/2`, (W/2)-34, 62);
      }

      g.font = "12px system-ui, Arial";
      g.fillText(`2PlayerTag  |  Dev: Mcant  |  Esc = Menu`, 14, H-12);
    }

    // start on menu + loop
    openMenu();
    requestAnimationFrame(step);
  </script>
</body>
</html>
