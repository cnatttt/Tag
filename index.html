<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2 Player Tag</title>

  <!-- Nice font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&display=swap" rel="stylesheet">

  <style>
    :root{
      --gold: #ffd400;
      --bg1: #0b1020;
      --bg2: #0a0630;
      --bg3: #120a2a;
    }
    html, body { height: 100%; margin: 0; }
    body{
      display:grid;
      place-items:center;
      overflow:hidden;
      font-family: Orbitron, system-ui, Arial;
      color:#fff;
      background:
        radial-gradient(circle at 50% 20%, rgba(255,212,0,.18), rgba(0,0,0,.75)),
        linear-gradient(120deg, var(--bg1), var(--bg2) 40%, var(--bg3));
    }

    .wrap{
      width:min(920px, 96vw);
      display:grid;
      gap: 12px;
      place-items:center;
    }

    .topbar{
      width:min(860px, 96vw);
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,212,0,0.25);
      box-shadow: 0 18px 50px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .left, .right{ display:flex; gap: 10px; align-items:center; flex-wrap:wrap; }
    .pill{
      display:flex; align-items:center; gap: 8px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.08);
    }
    .label{ opacity: .75; font-size: 12px; letter-spacing: .06em; }
    .value{ font-weight: 700; font-size: 14px; letter-spacing: .04em; }
    .dot{
      width:10px;height:10px;border-radius:999px;
      box-shadow: 0 0 20px rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.25);
    }

    canvas{
      width:min(860px, 96vw);
      height:min(860px, 96vw);
      max-width: 860px;
      max-height: 860px;
      border-radius: 18px;
      border: 2px solid rgba(255,212,0,.75);
      box-shadow: 0 20px 60px rgba(0,0,0,.55), 0 0 30px rgba(255,212,0,.12);
      background: transparent;
      image-rendering: pixelated;
      outline:none;
      display:block;
    }

    .hint{
      width:min(860px, 96vw);
      text-align:center;
      opacity:.85;
      font-size: 12px;
      letter-spacing:.04em;
    }

    .overlay{
      position:fixed; inset:0;
      display:grid; place-items:center;
      background: radial-gradient(circle at 50% 20%, rgba(255,212,0,.20), rgba(0,0,0,.75));
      padding: 18px;
    }
    .card{
      width:min(560px, 92vw);
      border-radius: 18px;
      background: rgba(15,15,28,0.72);
      border: 1px solid rgba(255,212,0,0.30);
      box-shadow: 0 30px 90px rgba(0,0,0,0.65);
      padding: 18px 18px 16px;
      text-align:center;
      backdrop-filter: blur(8px);
    }
    h1{
      margin: 2px 0 10px;
      font-size: 22px;
      letter-spacing: .06em;
    }
    .sub{ margin: 0 0 14px; opacity:.85; font-size: 12px; line-height:1.5; }
    .btns{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top: 10px; }
    button{
      cursor:pointer;
      font-family: inherit;
      font-weight: 700;
      letter-spacing:.05em;
      border-radius: 14px;
      border: 1px solid rgba(255,212,0,0.50);
      padding: 10px 14px;
      background: rgba(255,212,0,0.12);
      color: #fff;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
    }
    button:hover{ background: rgba(255,212,0,0.18); }
    .small{ opacity:.85; font-size: 11px; margin-top: 10px; }
    kbd{
      background: rgba(0,0,0,0.35);
      border: 1px solid rgba(255,255,255,0.12);
      padding: 2px 6px;
      border-radius: 8px;
      font-size: 11px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar" aria-hidden="true">
      <div class="left">
        <div class="pill">
          <span class="label">TIME</span>
          <span class="value" id="uiTime">60.0</span>
        </div>
        <div class="pill">
          <span class="label">SCORE</span>
          <span class="value" id="uiScore">P1 0 — 0 P2</span>
        </div>
      </div>
      <div class="right">
        <div class="pill">
          <span class="label">IT</span>
          <span class="dot" id="uiItDot"></span>
          <span class="value" id="uiItText">P1</span>
        </div>
        <div class="pill">
          <span class="label">ROUND</span>
          <span class="value" id="uiRound">1</span>
        </div>
      </div>
    </div>

    <canvas id="game" width="800" height="800" tabindex="0"></canvas>
    <div class="hint">
      P1: <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> • P2: <kbd>↑</kbd><kbd>←</kbd><kbd>↓</kbd><kbd>→</kbd> • <kbd>R</kbd> Restart
    </div>
  </div>

  <div class="overlay" id="overlay">
    <div class="card">
      <h1>2 Player Tag</h1>
      <p class="sub">
        Tag the other player before time runs out.<br>
        First tag each round earns a point. New round starts automatically.
      </p>
      <div class="btns">
        <button id="startBtn">START</button>
        <button id="muteBtn">SFX: ON</button>
      </div>
      <div class="small">
        Tip: Click the game once if keys don’t work.
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas / UI =====
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });
  const W = canvas.width, H = canvas.height;

  const uiTime = document.getElementById('uiTime');
  const uiScore = document.getElementById('uiScore');
  const uiItText = document.getElementById('uiItText');
  const uiItDot = document.getElementById('uiItDot');
  const uiRound = document.getElementById('uiRound');

  const overlay = document.getElementById('overlay');
  const startBtn = document.getElementById('startBtn');
  const muteBtn = document.getElementById('muteBtn');

  // ===== Input =====
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    keys.add(e.code);
    if (e.code === 'KeyR') hardReset();
    // prevent arrow keys from scrolling
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  }, { passive:false });
  window.addEventListener('keyup', (e) => keys.delete(e.code));

  canvas.addEventListener('pointerdown', () => canvas.focus());

  // ===== Simple SFX (no external files) =====
  let sfxOn = true;
  let audioCtx = null;
  function beep(freq=440, dur=0.06, type='square', vol=0.05){
    if (!sfxOn) return;
    try{
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const t0 = audioCtx.currentTime;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(vol, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g).connect(audioCtx.destination);
      o.start(t0);
      o.stop(t0 + dur + 0.02);
    }catch{}
  }
  function tagSound(){
    beep(740, 0.05, 'square', 0.06);
    beep(520, 0.07, 'square', 0.05);
  }
  function timeUpSound(){
    beep(220, 0.12, 'sawtooth', 0.05);
    beep(180, 0.14, 'sawtooth', 0.04);
  }

  muteBtn.onclick = () => {
    sfxOn = !sfxOn;
    muteBtn.textContent = `SFX: ${sfxOn ? 'ON' : 'OFF'}`;
    beep(660, 0.05, 'square', 0.04);
  };

  // ===== Helpers =====
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (ax,ay,bx,by) => (ax-bx)**2 + (ay-by)**2;
  function roundRectPath(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // ===== Game Config =====
  const ARENA_PAD = 18;
  const ROUND_TIME = 45; // seconds
  const MAX_SPEED = 330; // px/s
  const ACCEL = 1600;    // px/s^2
  const FRICTION = 0.88; // per frame-ish (we apply dt-aware)
  const TAG_DIST = 22;   // distance between centers to tag

  // Walls (feel free to edit)
  const walls = [
    // x,y,w,h
    {x: 150, y: 140, w: 500, h: 22},
    {x: 150, y: 638, w: 500, h: 22},
    {x: 140, y: 250, w: 22,  h: 300},
    {x: 638, y: 250, w: 22,  h: 300},
    {x: 330, y: 330, w: 140, h: 22},
    {x: 330, y: 448, w: 140, h: 22},
  ];

  // ===== Visual FX =====
  const particles = [];
  function spawnBurst(x,y,color){
    const n = 36;
    for(let i=0;i<n;i++){
      const a = (Math.PI*2) * (i/n) + (Math.random()*0.25);
      const s = 120 + Math.random()*260;
      particles.push({
        x,y,
        vx: Math.cos(a)*s,
        vy: Math.sin(a)*s,
        life: 0.55 + Math.random()*0.35,
        age: 0,
        r: 2 + Math.random()*3,
        color
      });
    }
  }

  let shake = 0; // intensity
  function addShake(amount){ shake = Math.max(shake, amount); }

  // ===== Players =====
  const p1 = { id:'P1', x: 240, y: 400, vx:0, vy:0, r: 16, color:'#35c7ff' };
  const p2 = { id:'P2', x: 560, y: 400, vx:0, vy:0, r: 16, color:'#ff4d6d' };
  let it = p1;

  // Score / round
  let score1 = 0, score2 = 0;
  let round = 1;
  let timeLeft = ROUND_TIME;
  let running = false;

  // ===== Collision =====
  function circleRectResolve(p, rx, ry, rw, rh){
    // Find closest point on rect to circle center
    const cx = clamp(p.x, rx, rx+rw);
    const cy = clamp(p.y, ry, ry+rh);
    const dx = p.x - cx, dy = p.y - cy;
    const d2 = dx*dx + dy*dy;
    const r = p.r;
    if (d2 < r*r){
      const d = Math.sqrt(d2) || 0.0001;
      const nx = dx / d, ny = dy / d;
      const push = r - d + 0.0005;
      p.x += nx * push;
      p.y += ny * push;

      // damp velocity on collision normal
      const vn = p.vx*nx + p.vy*ny;
      if (vn < 0){
        p.vx -= vn*nx*1.15;
        p.vy -= vn*ny*1.15;
      }
    }
  }

  function keepInArena(p){
    const minX = ARENA_PAD + p.r;
    const maxX = W - ARENA_PAD - p.r;
    const minY = ARENA_PAD + p.r;
    const maxY = H - ARENA_PAD - p.r;

    if (p.x < minX){ p.x = minX; p.vx *= -0.35; }
    if (p.x > maxX){ p.x = maxX; p.vx *= -0.35; }
    if (p.y < minY){ p.y = minY; p.vy *= -0.35; }
    if (p.y > maxY){ p.y = maxY; p.vy *= -0.35; }
  }

  // ===== Drawing =====
  function drawArena(t){
    // Base fill
    ctx.clearRect(0,0,W,H);

    // Animated glow gradient
    const pulse = 0.10 + 0.05*Math.sin(t*0.002);
    const g = ctx.createRadialGradient(W*0.5, H*0.33, 40, W*0.5, H*0.55, W*0.9);
    g.addColorStop(0, `rgba(255,212,0,${pulse})`);
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // Soft inner fill (gives depth)
    const bg = ctx.createLinearGradient(0,0,W,H);
    bg.addColorStop(0, 'rgba(13, 7, 130, 0.20)');
    bg.addColorStop(1, 'rgba(0, 0, 0, 0.05)');
    ctx.fillStyle = bg;
    ctx.fillRect(0,0,W,H);

    // Subtle grid
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.strokeStyle = '#ffd400';
    ctx.lineWidth = 1;
    const step = 40;
    for(let x=0; x<=W; x+=step){
      ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
    }
    for(let y=0; y<=H; y+=step){
      ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke();
    }
    ctx.restore();

    // Vignette
    const v = ctx.createRadialGradient(W/2,H/2, W*0.12, W/2,H/2, W*0.78);
    v.addColorStop(0,'rgba(0,0,0,0)');
    v.addColorStop(1,'rgba(0,0,0,0.55)');
    ctx.fillStyle = v;
    ctx.fillRect(0,0,W,H);

    // Arena border (pulse when low time)
    const low = timeLeft <= 8 ? (0.25 + 0.25*Math.sin(t*0.012)) : 0.18;
    ctx.save();
    ctx.shadowBlur = 18;
    ctx.shadowColor = `rgba(255,212,0,${0.28 + low})`;
    ctx.strokeStyle = `rgba(255,212,0,${0.75 + low})`;
    ctx.lineWidth = 4;
    roundRectPath(ctx, ARENA_PAD-6, ARENA_PAD-6, W-(ARENA_PAD-6)*2, H-(ARENA_PAD-6)*2, 16);
    ctx.stroke();
    ctx.restore();
  }

  function drawWalls(t){
    for(const w of walls){
      // wall glow
      ctx.save();
      ctx.shadowBlur = 18;
      ctx.shadowColor = 'rgba(255,212,0,0.22)';
      ctx.fillStyle = 'rgba(255,212,0,0.08)';
      roundRectPath(ctx, w.x, w.y, w.w, w.h, 10);
      ctx.fill();

      ctx.shadowBlur = 0;
      ctx.strokeStyle = 'rgba(255,212,0,0.55)';
      ctx.lineWidth = 2;
      roundRectPath(ctx, w.x, w.y, w.w, w.h, 10);
      ctx.stroke();

      // subtle animated edge shine
      const shine = 0.10 + 0.08*Math.sin(t*0.004 + (w.x+w.y)*0.01);
      ctx.strokeStyle = `rgba(255,255,255,${shine})`;
      ctx.lineWidth = 1;
      roundRectPath(ctx, w.x+1, w.y+1, w.w-2, w.h-2, 9);
      ctx.stroke();

      ctx.restore();
    }
  }

  function drawPlayer(p){
    ctx.save();

    // Trail (based on speed)
    const sp = Math.hypot(p.vx, p.vy);
    const trailN = Math.floor(clamp(sp/90, 0, 5));
    for(let i=trailN; i>0; i--){
      const k = i/(trailN+1);
      ctx.globalAlpha = 0.12 * (1-k);
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x - p.vx*0.012*i, p.y - p.vy*0.012*i, p.r*(0.95 - 0.08*k), 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // Shadow
    ctx.shadowBlur = 18;
    ctx.shadowColor = 'rgba(0,0,0,0.45)';

    // Body
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();

    // IT ring
    if (p === it){
      ctx.shadowBlur = 22;
      ctx.shadowColor = 'rgba(255,212,0,0.45)';
      ctx.strokeStyle = 'rgba(255,212,0,0.95)';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r+6, 0, Math.PI*2);
      ctx.stroke();
    }

    // Outline
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(255,255,255,0.35)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.stroke();

    // Highlight (fake lighting)
    const hg = ctx.createRadialGradient(p.x-p.r*0.35, p.y-p.r*0.35, 2, p.x, p.y, p.r);
    hg.addColorStop(0,'rgba(255,255,255,0.35)');
    hg.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = hg;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawParticles(dt){
    for(let i=particles.length-1; i>=0; i--){
      const p = particles[i];
      p.age += dt;
      if (p.age >= p.life){ particles.splice(i,1); continue; }
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.vx *= 0.98;
      p.vy *= 0.98;

      const a = 1 - (p.age / p.life);
      ctx.save();
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      ctx.shadowBlur = 12;
      ctx.shadowColor = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r * (0.7 + 0.6*a), 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }
  }

  // ===== Update / Physics =====
  function applyInput(p, dt){
    let ax = 0, ay = 0;

    if (p === p1){
      if (keys.has('KeyA')) ax -= ACCEL;
      if (keys.has('KeyD')) ax += ACCEL;
      if (keys.has('KeyW')) ay -= ACCEL;
      if (keys.has('KeyS')) ay += ACCEL;
    }else{
      if (keys.has('ArrowLeft')) ax -= ACCEL;
      if (keys.has('ArrowRight')) ax += ACCEL;
      if (keys.has('ArrowUp')) ay -= ACCEL;
      if (keys.has('ArrowDown')) ay += ACCEL;
    }

    p.vx += ax * dt;
    p.vy += ay * dt;

    // dt-aware friction
    const fr = Math.pow(FRICTION, dt*60);
    p.vx *= fr;
    p.vy *= fr;

    // clamp speed
    const sp = Math.hypot(p.vx, p.vy);
    if (sp > MAX_SPEED){
      const k = MAX_SPEED / sp;
      p.vx *= k; p.vy *= k;
    }

    p.x += p.vx * dt;
    p.y += p.vy * dt;

    // collide with walls
    for(const w of walls){
      circleRectResolve(p, w.x, w.y, w.w, w.h);
    }

    keepInArena(p);
  }

  function checkTag(){
    const d2 = dist2(p1.x,p1.y,p2.x,p2.y);
    const r = TAG_DIST + p1.r + p2.r;
    if (d2 <= r*r){
      // IT tags the other
      const tagger = it;
      const tagged = (it === p1) ? p2 : p1;

      // score
      if (tagger === p1) score1++;
      else score2++;

      // swap IT
      it = tagged;

      // FX
      spawnBurst((p1.x+p2.x)/2, (p1.y+p2.y)/2, 'rgba(255,212,0,0.95)');
      spawnBurst(tagged.x, tagged.y, tagged.color);
      addShake(10);
      tagSound();

      // new round
      nextRound();
    }
  }

  function nextRound(){
    round++;
    timeLeft = ROUND_TIME;

    // reset positions a bit (keep it simple)
    p1.x = 240; p1.y = 400; p1.vx = 0; p1.vy = 0;
    p2.x = 560; p2.y = 400; p2.vx = 0; p2.vy = 0;

    // little pop
    spawnBurst(W/2, H/2, 'rgba(255,255,255,0.35)');
  }

  function hardReset(){
    score1 = 0; score2 = 0;
    round = 1;
    timeLeft = ROUND_TIME;
    it = p1;
    p1.x = 240; p1.y = 400; p1.vx=0; p1.vy=0;
    p2.x = 560; p2.y = 400; p2.vx=0; p2.vy=0;
    particles.length = 0;
    addShake(6);
    beep(520, 0.05, 'square', 0.05);
  }

  // ===== UI =====
  function updateUI(){
    uiTime.textContent = timeLeft.toFixed(1);
    uiScore.textContent = `P1 ${score1} — ${score2} P2`;
    uiItText.textContent = it.id;
    uiRound.textContent = String(round);
    uiItDot.style.background = (it === p1) ? p1.color : p2.color;
  }

  // ===== Loop =====
  let last = performance.now();

  function frame(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (running){
      timeLeft -= dt;
      if (timeLeft <= 0){
        timeLeft = 0;
        timeUpSound();
        addShake(10);
        // no score on timeout, just start next round
        nextRound();
      }

      applyInput(p1, dt);
      applyInput(p2, dt);
      checkTag();
    }

    // camera shake
    let sx = 0, sy = 0;
    if (shake > 0.01){
      sx = (Math.random()*2 - 1) * shake;
      sy = (Math.random()*2 - 1) * shake;
      shake *= 0.90;
    }else{
      shake = 0;
    }

    ctx.save();
    ctx.translate(sx, sy);

    drawArena(now);
    drawWalls(now);
    drawPlayer(p1);
    drawPlayer(p2);
    drawParticles(dt);

    ctx.restore();

    updateUI();
    requestAnimationFrame(frame);
  }

  // ===== Start =====
  startBtn.onclick = async () => {
    overlay.style.display = 'none';
    running = true;
    canvas.focus();
    // unlock audio on gesture
    beep(660, 0.05, 'square', 0.04);
  };

  // Start animating immediately (even on menu)
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
