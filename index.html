<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tag Game (800×800)</title>
  <style>
    html, body { height: 100%; margin: 0; }
    body {
      display: grid;
      place-items: center;
      background: #0b0b12;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #fff;
    }
    canvas {
      width: 800px;
      height: 800px;
      image-rendering: pixelated;
      border: 2px solid #f6e04a;
      background: rgb(13, 7, 130);
      outline: none;
    }
    .hint { margin-top: 10px; opacity: 0.8; font-size: 14px; }
    .hint kbd { background: #1f2330; padding: 2px 6px; border-radius: 6px; border: 1px solid #3a3f52; }
  </style>
</head>
<body>
  <div>
    <canvas id="game" width="800" height="800" tabindex="0" aria-label="Tag Game Canvas"></canvas>
    <div class="hint">
      Click the canvas to focus. P1:
      <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> &nbsp;|&nbsp;
      P2: <kbd>↑</kbd><kbd>←</kbd><kbd>↓</kbd><kbd>→</kbd>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const w = 800, h = 800;
      const boxWH = 20;
      const SPEED = 8;

      // Game state
      let px = 0, py = 0;     // P2 (arrows)
      let px2 = 0, py2 = 0;   // P1 (WASD)
      let count = 0;          // swap tagger each round
      let p1Score = 0, p2Score = 0;

      const ROUND_TIME_TICKS = 1500; // 1500 * 20ms = 30s
      let roundTicks = ROUND_TIME_TICKS;

      // Inputs
      const keys = {
        left:false,right:false,up:false,down:false,
        W:false,A:false,S:false,D:false
      };

      // Obstacles
      const obs = [
        rect(160, 160, 280, 20),
        rect(520, 160, 120, 20),

        rect(160, 620, 120, 20),
        rect(360, 620, 280, 20),

        rect(160, 160, 20, 220),
        rect(160, 460, 20, 180),

        rect(620, 160, 20, 180),
        rect(620, 460, 20, 180),

        rect(360, 260, 30, 30),
        rect(430, 260, 30, 30),
        rect(360, 510, 30, 30),
        rect(430, 510, 30, 30),

        rect(90, 280, 60, 20),
        rect(90, 500, 60, 20),
        rect(650, 280, 60, 20),
        rect(650, 500, 60, 20)
      ];

      function rect(x,y,width,height){ return {x,y,width,height}; }

      function resetPositionsOnly() {
        px2 = 30; py2 = 30;
        px  = w - 30 - (boxWH + 10);
        py  = h - 30 - (boxWH + 10);
        roundTicks = ROUND_TIME_TICKS;
      }

      function resetRound() {
        resetPositionsOnly();
        count++;
      }

      function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

      function intersects(a, b) {
        return (a.x < b.x + b.width &&
                a.x + a.width > b.x &&
                a.y < b.y + b.height &&
                a.y + a.height > b.y);
      }

      function grow(r, gx, gy) {
        return {
          x: r.x - gx,
          y: r.y - gy,
          width: r.width + gx*2,
          height: r.height + gy*2
        };
      }

      // Slide collision: test X then Y
      function slideMove(x, y, vx, vy, size) {
        const oldX = x, oldY = y;

        x += vx; y += vy;

        let testX = { x, y: oldY, width: size, height: size };
        for (const r of obs) {
          if (intersects(testX, r)) { x = oldX; break; }
        }

        let testY = { x, y, width: size, height: size };
        for (const r of obs) {
          if (intersects(testY, r)) { y = oldY; break; }
        }

        x = clamp(x, 0, w - size);
        y = clamp(y, 0, h - size);

        return {x,y};
      }

      function update() {
        const p1IsTagger = (count % 2 === 1);

        const p2Size = (count % 2 === 0) ? (boxWH + 10) : boxWH;
        const p1Size = (count % 2 === 0) ? boxWH : (boxWH + 10);

        const tagSpeed = SPEED + 1;
        const runSpeed = SPEED;
        const p1Speed = p1IsTagger ? tagSpeed : runSpeed;
        const p2Speed = p1IsTagger ? runSpeed : tagSpeed;

        let vX = 0, vY = 0;
        if (keys.left)  vX = -p2Speed;
        if (keys.right) vX =  p2Speed;
        if (keys.up)    vY = -p2Speed;
        if (keys.down)  vY =  p2Speed;

        let vX2 = 0, vY2 = 0;
        if (keys.A) vX2 = -p1Speed;
        if (keys.D) vX2 =  p1Speed;
        if (keys.W) vY2 = -p1Speed;
        if (keys.S) vY2 =  p1Speed;

        ({x:px,  y:py } = slideMove(px,  py,  vX,  vY,  p2Size));
        ({x:px2, y:py2} = slideMove(px2, py2, vX2, vY2, p1Size));

        const p1HB = { x:px2, y:py2, width:p1Size, height:p1Size };
        const p2HB = { x:px,  y:py,  width:p2Size, height:p2Size };

        if (roundTicks > 0) roundTicks--;

        let tagHB1 = {...p1HB};
        let tagHB2 = {...p2HB};
        if (p1IsTagger) tagHB1 = grow(tagHB1, 4, 4);
        else           tagHB2 = grow(tagHB2, 4, 4);

        if (intersects(tagHB1, tagHB2)) {
          if (p1IsTagger) p1Score++;
          else p2Score++;
          resetRound();
        } else if (roundTicks <= 0) {
          if (p1IsTagger) p2Score++;
          else p1Score++;
          resetRound();
        }
      }

      function draw() {
        ctx.clearRect(0, 0, w, h);

        // grid
        ctx.strokeStyle = "rgb(25,25,25)";
        ctx.lineWidth = 1;
        for (let x = 0; x < w; x += 40) {
          ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke();
        }
        for (let y = 0; y < h; y += 40) {
          ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke();
        }

        // obstacles
        for (const r of obs) {
          ctx.fillStyle = "rgb(0,180,255)";
          ctx.fillRect(r.x, r.y, r.width, r.height);
          ctx.strokeStyle = "#ffffff";
          ctx.strokeRect(r.x, r.y, r.width, r.height);
        }

        const p1IsTagger = (count % 2 === 1);
        const p2Size = (count % 2 === 0) ? (boxWH + 10) : boxWH;
        const p1Size = (count % 2 === 0) ? boxWH : (boxWH + 10);

        if (count % 2 === 0) {
          ctx.fillStyle = "#ff2a2a";
          ctx.fillRect(px, py, p2Size, p2Size);
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(px2, py2, p1Size, p1Size);
        } else {
          ctx.fillStyle = "#ffffff";
          ctx.fillRect(px, py, p2Size, p2Size);
          ctx.fillStyle = "#ff2a2a";
          ctx.fillRect(px2, py2, p1Size, p1Size);
        }

        // border
        ctx.strokeStyle = "#f6e04a";
        ctx.lineWidth = 2;
        ctx.strokeRect(0.5, 0.5, w - 1, h - 1);

        // HUD
        const secondsLeft = Math.floor((roundTicks + 49) / 50);
        ctx.fillStyle = "#ffffff";
        ctx.font = "16px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(`P1: ${p1Score}`, 15, 20);
        ctx.fillText(`TIME: ${secondsLeft}`, (w/2) - 35, 20);
        ctx.fillText(`P2: ${p2Score}`, w - 70, 20);

        ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        ctx.fillText(p1IsTagger ? "TAGGER" : "RUNNER", 15, 40);
        ctx.fillText(p1IsTagger ? "RUNNER" : "TAGGER", w - 85, 40);

        ctx.fillText("Dev: Mcant", 10, h - 10);
      }

      function setKey(e, isDown) {
        const k = e.key;
        if (k === "ArrowLeft")  keys.left = isDown;
        if (k === "ArrowRight") keys.right = isDown;
        if (k === "ArrowUp")    keys.up = isDown;
        if (k === "ArrowDown")  keys.down = isDown;

        if (k === "w" || k === "W") keys.W = isDown;
        if (k === "a" || k === "A") keys.A = isDown;
        if (k === "s" || k === "S") keys.S = isDown;
        if (k === "d" || k === "D") keys.D = isDown;

        if (["ArrowLeft","ArrowRight","ArrowUp","ArrowDown"].includes(k)) {
          e.preventDefault();
        }
      }

      window.addEventListener("keydown", (e) => setKey(e, true), {passive:false});
      window.addEventListener("keyup",   (e) => setKey(e, false), {passive:false});

      canvas.addEventListener("pointerdown", () => canvas.focus());

      resetPositionsOnly();
      setInterval(update, 20);

      function loop() {
        draw();
        requestAnimationFrame(loop);
      }
      loop();
    })();
  </script>
</body>
</html>
