<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tag Game</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0d0782; font-family: system-ui, Arial; }
    .wrap { height: 100%; display:flex; align-items:center; justify-content:center; }
    canvas { background:#0d0782; border:2px solid #ffd400; image-rendering: pixelated; }
    .ui {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: rgba(0,0,0,.55);
    }
    .card {
      width: min(520px, 92vw);
      background: #0b0b18;
      border: 2px solid #2b2b55;
      border-radius: 16px;
      padding: 20px;
      color: #fff;
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    .title { font-size: 22px; font-weight: 800; margin: 0 0 6px; }
    .sub { opacity: .85; margin: 0 0 16px; line-height: 1.35; }
    .btns { display:flex; gap: 12px; flex-wrap: wrap; }
    button {
      cursor:pointer;
      border: 2px solid #3b3b7a;
      background:#121235;
      color:#fff;
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 700;
      transition: transform .05s ease, background .15s ease;
    }
    button:hover { background:#181847; }
    button:active { transform: translateY(1px); }
    .hint { margin-top: 14px; opacity:.85; font-size: 13px; line-height:1.35; }
    kbd { background:#111; border:1px solid #333; border-bottom-width:2px; padding:2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="800" height="800"></canvas>
  </div>

  <div class="ui" id="menu">
    <div class="card">
      <p class="title">Tag Game</p>
      <p class="sub">
        Choose a mode. Tagger is slightly faster + has a tiny reach buff.
        Survive the timer to score as runner.
      </p>
      <div class="btns">
        <button id="twoP">2 Player</button>
        <button id="oneP">1 Player vs AI</button>
        <button id="reset">Reset Scores</button>
      </div>
      <div class="hint">
        <div><b>Player 1 (top-left):</b> <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></div>
        <div><b>Player 2 (bottom-right):</b> Arrow Keys (or AI in 1P)</div>
        <div style="margin-top:8px;">Press <b>Esc</b> to return to this menu anytime.</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("c");
    const g = canvas.getContext("2d");

    const menu = document.getElementById("menu");
    const twoPBtn = document.getElementById("twoP");
    const onePBtn = document.getElementById("oneP");
    const resetBtn = document.getElementById("reset");

    const W = canvas.width, H = canvas.height;

    // ---------- MAP / OBSTACLES ----------
    const obs = [
      // top
      {x:160,y:160,w:280,h:20},
      {x:520,y:160,w:120,h:20},
      // bottom
      {x:160,y:620,w:120,h:20},
      {x:360,y:620,w:280,h:20},
      // left
      {x:160,y:160,w:20,h:220},
      {x:160,y:460,w:20,h:180},
      // right
      {x:620,y:160,w:20,h:180},
      {x:620,y:460,w:20,h:180},
      // center pillars
      {x:360,y:260,w:30,h:30},
      {x:430,y:260,w:30,h:30},
      {x:360,y:510,w:30,h:30},
      {x:430,y:510,w:30,h:30},
      // side bumpers
      {x:90,y:280,w:60,h:20},
      {x:90,y:500,w:60,h:20},
      {x:650,y:280,w:60,h:20},
      {x:650,y:500,w:60,h:20},
    ];

    function rectsIntersect(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
    }
    function rectIntersectsAny(r){
      for(const o of obs){
        if(rectsIntersect(r, o)) return true;
      }
      return false;
    }
    function dist(ax, ay, bx, by){
      const dx = ax - bx, dy = ay - by;
      return Math.hypot(dx, dy);
    }
    function clamp01(v){ return Math.max(0, Math.min(1, v)); }

    // "LOS" sampling (good enough)
    function hasLOS(ax, ay, bx, by, size){
      const steps = 10;
      for(let i=1;i<=steps;i++){
        const t = i/steps;
        const x = ax + (bx-ax)*t;
        const y = ay + (by-ay)*t;
        const r = {x:x, y:y, w:size, h:size};
        if(rectIntersectsAny(r)) return false;
      }
      return true;
    }

    // try a move without committing (sliding)
    function tryMove(x, y, dx, dy, size){
      let nx = x, ny = y;

      // X slide
      nx += dx;
      let testX = {x:nx, y:y, w:size, h:size};
      if(rectIntersectsAny(testX)) nx = x;

      // Y slide
      ny += dy;
      let testY = {x:nx, y:ny, w:size, h:size};
      if(rectIntersectsAny(testY)) ny = y;

      // clamp
      nx = Math.max(0, Math.min(W - size, nx));
      ny = Math.max(0, Math.min(H - size, ny));

      return {x:nx, y:ny};
    }
    function slideMove(p, dx, dy, size){
      const nxt = tryMove(p.x, p.y, dx, dy, size);
      p.x = nxt.x; p.y = nxt.y;
    }

    // ---------- GAME STATE ----------
    const base = 20;
    const big  = base + 10;

    // P1 top-left (WASD)
    const p1 = { x:30,  y:30,  score:0 };
    // P2 bottom-right (arrows / AI)
    const p2 = { x:740, y:740, score:0 };

    // count%2==0 => P2 is big (tagger); count%2==1 => P1 is big (tagger)
    let count = 0;

    // ✅ 20 seconds @ 50 ticks/sec
    const ROUND_TICKS = 1000;
    let roundTicks = ROUND_TICKS;

    // fairness knobs
    const SPEED = 8;
    const TAG_SPEED = SPEED + 1;
    const TAG_REACH = 4;

    // mode
    let mode = "menu"; // "2p" | "1p"
    let running = false;

    const keys = new Set();
    window.addEventListener("keydown", (e)=>{
      if(e.key === "Escape"){ openMenu(); }
      keys.add(e.key.toLowerCase());
      if(["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key.toLowerCase())) e.preventDefault();
    }, {passive:false});
    window.addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()));

    function openMenu(){
      running = false;
      mode = "menu";
      menu.style.display = "flex";
    }

    function startGame(which){
      mode = which;
      running = true;
      menu.style.display = "none";
      resetRound(false); // don't swap roles on start
    }

    function resetRound(swapRoles=true){
      p1.x = 30;  p1.y = 30;
      p2.x = 740; p2.y = 740;
      if(swapRoles) count++;
      roundTicks = ROUND_TICKS;

      // reset AI state too (helps prevent immediate “stuck” behavior)
      aiState.lastX = p2.x;
      aiState.lastY = p2.y;
      aiState.stuckTicks = 0;
      aiState.escapeTicks = 0;
      aiState.jitterTimer = 0;
    }

    resetBtn.onclick = ()=>{ p1.score = 0; p2.score = 0; };
    twoPBtn.onclick = ()=> startGame("2p");
    onePBtn.onclick = ()=> startGame("1p");

    function isP1Tagger(){ return (count % 2 === 1); }
    function sizeForP1(){ return isP1Tagger() ? big : base; }
    function sizeForP2(){ return isP1Tagger() ? base : big; }

    // ---------- HUMAN-LIKE AI STATE ----------
    let aiState = {
      jitterAngle: 0,
      jitterTimer: 0,
      lastX: 740,
      lastY: 740,
      stuckTicks: 0,
      escapeDx: 0,
      escapeDy: 0,
      escapeTicks: 0
    };

    // Wall repulsion (prevents corner camping)
    function wallRepel(x, y, size){
      const margin = 110;     // start pushing this far from walls
      const strength = 1.35;  // push amount
      let rx = 0, ry = 0;

      const leftD   = x;
      const rightD  = (W - size) - x;
      const topD    = y;
      const bottomD = (H - size) - y;

      if(leftD < margin)   rx += (margin - leftD) / margin;
      if(rightD < margin)  rx -= (margin - rightD) / margin;
      if(topD < margin)    ry += (margin - topD) / margin;
      if(bottomD < margin) ry -= (margin - bottomD) / margin;

      const len = Math.hypot(rx, ry) || 1;
      return { x: (rx/len)*strength, y: (ry/len)*strength };
    }

    // Obstacle repulsion (keeps it from sticking to blocks)
    function obstacleRepel(x, y, size){
      const strength = 1.10;
      let rx = 0, ry = 0;

      const cx = x + size/2;
      const cy = y + size/2;

      for(const o of obs){
        const nx = Math.max(o.x, Math.min(cx, o.x + o.w));
        const ny = Math.max(o.y, Math.min(cy, o.y + o.h));
        const dx = cx - nx;
        const dy = cy - ny;
        const d = Math.hypot(dx, dy);

        const radius = 80;
        if(d > 0.001 && d < radius){
          const push = (radius - d) / radius;
          rx += (dx / d) * push;
          ry += (dy / d) * push;
        }
      }

      const len = Math.hypot(rx, ry) || 1;
      return { x: (rx/len)*strength, y: (ry/len)*strength };
    }

    // ✅ HUMAN AI (works as tagger AND runner)
    function aiStep(){
      const ai = p2;                     // AI controls P2 in 1P mode
      const p1Tagger = isP1Tagger();
      const aiIsTagger = !p1Tagger;

      const aiSize  = sizeForP2();
      const oppSize = sizeForP1();
      const opp = p1;

      const aiSpeed = aiIsTagger ? TAG_SPEED : SPEED;

      // ---- stuck detection
      const moved = dist(ai.x, ai.y, aiState.lastX, aiState.lastY);
      aiState.lastX = ai.x;
      aiState.lastY = ai.y;
      aiState.stuckTicks = (moved < 0.5) ? (aiState.stuckTicks + 1) : 0;

      // escape mode if stuck
      if(aiState.escapeTicks > 0){
        aiState.escapeTicks--;
        const nxt = tryMove(ai.x, ai.y, aiState.escapeDx * aiSpeed, aiState.escapeDy * aiSpeed, aiSize);
        ai.x = nxt.x; ai.y = nxt.y;
        return;
      }
      if(aiState.stuckTicks > 12){
        aiState.stuckTicks = 0;
        const dirs = [
          {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},
          {x:0.7,y:0.7},{x:0.7,y:-0.7},{x:-0.7,y:0.7},{x:-0.7,y:-0.7}
        ];
        const pick = dirs[Math.floor(Math.random()*dirs.length)];
        aiState.escapeDx = pick.x;
        aiState.escapeDy = pick.y;
        aiState.escapeTicks = 22;
      }

      // ---- jitter (human wobble)
      aiState.jitterTimer--;
      if(aiState.jitterTimer <= 0){
        aiState.jitterTimer = 12 + Math.floor(Math.random()*18);
        aiState.jitterAngle = Math.random() * Math.PI * 2;
      }
      const jx = Math.cos(aiState.jitterAngle) * (aiIsTagger ? 0.08 : 0.22);
      const jy = Math.sin(aiState.jitterAngle) * (aiIsTagger ? 0.08 : 0.22);

      // ---- predict opponent a bit (lead)
      let p1vx = 0, p1vy = 0;
      const p1MoveSpeed = p1Tagger ? TAG_SPEED : SPEED;
      if(keys.has("w")) p1vy -= p1MoveSpeed;
      if(keys.has("s")) p1vy += p1MoveSpeed;
      if(keys.has("a")) p1vx -= p1MoveSpeed;
      if(keys.has("d")) p1vx += p1MoveSpeed;

      const lead = aiIsTagger ? 11 : 6;
      let tx = opp.x + p1vx * lead;
      let ty = opp.y + p1vy * lead;
      tx = Math.max(0, Math.min(W - oppSize, tx));
      ty = Math.max(0, Math.min(H - oppSize, ty));

      // ---- steering helpers
      const wallPush = wallRepel(ai.x, ai.y, aiSize);
      const obsPush  = obstacleRepel(ai.x, ai.y, aiSize);

      // Candidate directions
      const dirs = [
        {x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1},
        {x:0.707,y:0.707},{x:0.707,y:-0.707},{x:-0.707,y:0.707},{x:-0.707,y:-0.707},
        {x:0.92,y:0.38},{x:0.92,y:-0.38},{x:-0.92,y:0.38},{x:-0.92,y:-0.38},
      ];

      let best = null;
      let bestScore = -1e9;

      // vector to target (predicted)
      let vx = tx - ai.x;
      let vy = ty - ai.y;
      let vlen = Math.hypot(vx, vy) || 1;
      vx /= vlen; vy /= vlen;

      // for tagger: add “side angle” to reduce wall-pin behavior
      // perpendicular to target vector
      const pxv = -vy;
      const pyv = vx;

      for(const d of dirs){
        // base move dir
        let mx = d.x;
        let my = d.y;

        // bias toward goal
        if(aiIsTagger){
          // chase but with some sideways approach so it doesn't just ram walls
          const side = ((count + Math.floor(roundTicks/40)) % 2 === 0) ? 1 : -1;
          mx = mx*0.55 + vx*0.85 + pxv*(0.35*side);
          my = my*0.55 + vy*0.85 + pyv*(0.35*side);
        } else {
          // runner: flee (opposite of target vector)
          mx = mx*0.55 - vx*0.95;
          my = my*0.55 - vy*0.95;
        }

        // add repulsions + jitter (prevents corner glue + obstacle hugging)
        mx += wallPush.x + obsPush.x + jx;
        my += wallPush.y + obsPush.y + jy;

        // normalize
        const len = Math.hypot(mx,my) || 1;
        mx /= len; my /= len;

        const step = tryMove(ai.x, ai.y, mx * aiSpeed, my * aiSpeed, aiSize);
        const stepDist = dist(ai.x, ai.y, step.x, step.y);
        if(stepDist < 0.1) continue;

        // scoring
        const dToOpp = dist(step.x, step.y, opp.x, opp.y);

        // edge penalty (don’t camp borders)
        const edge = Math.min(step.x, step.y, (W-aiSize)-step.x, (H-aiSize)-step.y);
        const edgeScore = clamp01(edge / 110) * 25;

        // obstacle closeness penalty (don’t glue to blocks)
        const opush = obstacleRepel(step.x, step.y, aiSize);
        const obstaclePenalty = (Math.hypot(opush.x, opush.y)) * 10;

        // LOS behavior:
        // - runner prefers to BREAK LOS (hide behind obstacles)
        // - tagger prefers to KEEP LOS (pressure + cutoffs)
        const los = hasLOS(step.x, step.y, opp.x, opp.y, aiSize);

        let score = 0;

        if(aiIsTagger){
          score += (-dToOpp);                 // closer is better
          score += (los ? 18 : -12);          // keep pressure
          score += edgeScore;                 // stay off borders (harder to trap)
          score -= obstaclePenalty;           // avoid sticking to obstacles

          // extra: if very close to opponent, avoid being pinned to walls
          if(dToOpp < 80){
            const wpush = wallRepel(step.x, step.y, aiSize);
            score -= Math.hypot(wpush.x, wpush.y) * 10;
          }
        } else {
          score += (dToOpp);                  // farther is better
          score += (!los ? 22 : -10);         // prefer hiding / breaking sight
          score += edgeScore * 1.2;           // strongly avoid corners
          score -= obstaclePenalty;

          // prefer “open space”
          let open = 0;
          for(let k=0;k<6;k++){
            const ang = (k/6)*Math.PI*2;
            const rx = step.x + Math.cos(ang)*65;
            const ry = step.y + Math.sin(ang)*65;
            if(hasLOS(step.x, step.y, rx, ry, aiSize)) open++;
          }
          score += open * 6;
        }

        // small randomness (human imperfection)
        score += (Math.random() - 0.5) * (aiIsTagger ? 2.0 : 4.0);

        if(score > bestScore){
          bestScore = score;
          best = step;
        }
      }

      if(best){
        ai.x = best.x;
        ai.y = best.y;
      }
    }

    // ---------- GAME LOOP ----------
    function step(){
      if(!running){ draw(); requestAnimationFrame(step); return; }

      const p1Tag = isP1Tagger();
      const p1Size = sizeForP1();
      const p2Size = sizeForP2();

      const p1Speed = p1Tag ? TAG_SPEED : SPEED;
      const p2Speed = p1Tag ? SPEED : TAG_SPEED;

      // P1 (WASD)
      let p1dx = 0, p1dy = 0;
      if(keys.has("w")) p1dy -= p1Speed;
      if(keys.has("s")) p1dy += p1Speed;
      if(keys.has("a")) p1dx -= p1Speed;
      if(keys.has("d")) p1dx += p1Speed;
      slideMove(p1, p1dx, p1dy, p1Size);

      // P2 (arrows) or AI
      if(mode === "2p"){
        let p2dx = 0, p2dy = 0;
        if(keys.has("arrowup")) p2dy -= p2Speed;
        if(keys.has("arrowdown")) p2dy += p2Speed;
        if(keys.has("arrowleft")) p2dx -= p2Speed;
        if(keys.has("arrowright")) p2dx += p2Speed;
        slideMove(p2, p2dx, p2dy, p2Size);
      } else if(mode === "1p") {
        aiStep();
      }

      // timer
      if(roundTicks > 0) roundTicks--;

      // tag check with reach buff
      let hb1 = {x:p1.x, y:p1.y, w:p1Size, h:p1Size};
      let hb2 = {x:p2.x, y:p2.y, w:p2Size, h:p2Size};

      if(p1Tag){
        hb1 = {x:hb1.x - TAG_REACH, y:hb1.y - TAG_REACH, w:hb1.w + TAG_REACH*2, h:hb1.h + TAG_REACH*2};
      } else {
        hb2 = {x:hb2.x - TAG_REACH, y:hb2.y - TAG_REACH, w:hb2.w + TAG_REACH*2, h:hb2.h + TAG_REACH*2};
      }

      const tagged = rectsIntersect(hb1, hb2);

      if(tagged){
        if(p1Tag) p1.score++; else p2.score++;
        resetRound(true);
      } else if(roundTicks <= 0){
        if(p1Tag) p2.score++; else p1.score++;
        resetRound(true);
      }

      draw();
      requestAnimationFrame(step);
    }

    function draw(){
      g.clearRect(0,0,W,H);

      // grid
      g.strokeStyle = "rgb(25,25,25)";
      for(let x=0;x<W;x+=40){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke(); }
      for(let y=0;y<H;y+=40){ g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.stroke(); }

      // obstacles
      g.fillStyle = "rgb(0,180,255)";
      g.strokeStyle = "white";
      for(const r of obs){
        g.fillRect(r.x,r.y,r.w,r.h);
        g.strokeRect(r.x,r.y,r.w,r.h);
      }

      // players
      const p1Tag = isP1Tagger();
      const p1Size = sizeForP1();
      const p2Size = sizeForP2();

      g.fillStyle = p1Tag ? "red" : "white";
      g.fillRect(p1.x, p1.y, p1Size, p1Size);

      g.fillStyle = p1Tag ? "white" : "red";
      g.fillRect(p2.x, p2.y, p2Size, p2Size);

      // border
      g.strokeStyle = "#ffd400";
      g.strokeRect(0.5,0.5,W-1,H-1);

      // UI
      const secondsLeft = Math.ceil(roundTicks / 50);

      g.fillStyle = "white";
      g.font = "16px system-ui, Arial";
      g.fillText(`P1: ${p1.score}`, 14, 22);
      g.fillText(`TIME: ${secondsLeft}`, (W/2)-34, 22);
      g.fillText(`P2: ${p2.score}`, W-70, 22);

      g.font = "14px system-ui, Arial";
      g.fillText(p1Tag ? "TAGGER" : "RUNNER", 14, 44);
      g.fillText(p1Tag ? "RUNNER" : "TAGGER", W-82, 44);

      g.font = "12px system-ui, Arial";
      g.fillText(`Mode: ${mode === "1p" ? "1P vs AI" : (mode === "2p" ? "2P" : "Menu")}  |  Esc = Menu`, 14, H-12);
    }

    // UI hooks (already set above, but safe)
    resetBtn.onclick = ()=>{ p1.score = 0; p2.score = 0; };
    twoPBtn.onclick = ()=> startGame("2p");
    onePBtn.onclick = ()=> startGame("1p");

    // start at menu
    openMenu();
    requestAnimationFrame(step);
  </script>
</body>
</html>
