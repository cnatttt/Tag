Alright — here’s the FULL HTML CODE again with both players able to grab power-ups (like before), power-ups toggle in the menu, 30 second rounds, and NO map/mechanic changes beyond the power-up system itself.

Copy/paste into a file named 2PlayerTag.html:

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>2PlayerTag</title>
  <style>
    html, body { height: 100%; margin: 0; background:#0d0782; font-family: system-ui, Arial; }
    .wrap { height: 100%; display:flex; align-items:center; justify-content:center; }
    canvas { background:#0d0782; border:2px solid #ffd400; image-rendering: pixelated; }

    .ui {
      position: fixed; inset: 0;
      display:flex; align-items:center; justify-content:center;
      background: radial-gradient(circle at 50% 20%, rgba(255,212,0,.18), rgba(0,0,0,.65));
    }
    .card {
      width: min(560px, 92vw);
      background: rgba(10,10,25,.92);
      border: 2px solid rgba(255,212,0,.35);
      border-radius: 18px;
      padding: 20px;
      color: #fff;
      box-shadow: 0 22px 70px rgba(0,0,0,.55);
      position: relative;
      overflow: hidden;
    }
    .glow {
      position:absolute; inset:-40px;
      background: conic-gradient(from 180deg, rgba(0,180,255,.0), rgba(0,180,255,.25), rgba(255,212,0,.2), rgba(0,180,255,.0));
      filter: blur(30px);
      opacity: .55;
      animation: spin 6s linear infinite;
      pointer-events:none;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .title { font-size: 26px; font-weight: 900; margin: 0 0 4px; letter-spacing: .4px; }
    .dev { opacity:.9; margin: 0 0 14px; font-weight: 700; }
    .sub { opacity: .85; margin: 0 0 14px; line-height: 1.35; }

    .row { display:flex; gap: 12px; flex-wrap: wrap; align-items:center; }
    button {
      cursor:pointer;
      border: 2px solid rgba(0,180,255,.35);
      background: rgba(18,18,50,.9);
      color:#fff;
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 800;
      transition: transform .05s ease, background .15s ease, border-color .15s ease;
    }
    button:hover { background: rgba(25,25,70,.95); border-color: rgba(255,212,0,.5); }
    button:active { transform: translateY(1px); }

    .sliderBox {
      flex: 1 1 220px;
      border: 2px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 12px;
      background: rgba(255,255,255,.04);
    }
    .sliderBox label { display:flex; justify-content:space-between; font-weight:800; opacity:.95; }
    input[type="range"] { width: 100%; margin-top: 8px; }

    .hint { margin-top: 14px; opacity:.9; font-size: 13px; line-height:1.45; }
    kbd { background:#111; border:1px solid #333; border-bottom-width:2px; padding:2px 6px; border-radius:6px; }
    .tip {
      margin-top: 10px;
      font-size: 12px;
      opacity: .85;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255,212,0,.25);
      background: rgba(255,212,0,.06);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="800" height="800"></canvas>
  </div>

  <div class="ui" id="menu">
    <div class="card">
      <div class="glow"></div>

      <p class="title">2PlayerTag</p>
      <p class="dev">Dev: Mcant</p>
      <p class="sub">
        Survive <b>30 seconds</b> as runner to score. Tagger gets a small speed + reach buff.
        Power-ups spawn randomly (toggle below).
      </p>

      <div class="row">
        <button id="play">PLAY</button>
        <button id="resetScore">RESET SCORE</button>

        <div class="sliderBox">
          <label>
            <span>Volume</span>
            <span id="volLabel">70%</span>
          </label>
          <input id="vol" type="range" min="0" max="100" value="70" />
        </div>

        <div class="sliderBox">
          <label>
            <span>Power-ups</span>
            <span id="puLabel">ON</span>
          </label>
          <input id="puToggle" type="range" min="0" max="1" step="1" value="1" />
        </div>
      </div>

      <div class="hint">
        <div><b>Player 1 (top-left):</b> <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd></div>
        <div><b>Player 2 (bottom-right):</b> Arrow Keys</div>
        <div style="margin-top:8px;">Press <b>Esc</b> to go back to the menu.</div>
      </div>

      <div class="tip" id="tipBox">Tip: (loads when you open the menu)</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("c");
    const g = canvas.getContext("2d");

    const menu = document.getElementById("menu");
    const playBtn = document.getElementById("play");
    const resetScoreBtn = document.getElementById("resetScore");
    const vol = document.getElementById("vol");
    const volLabel = document.getElementById("volLabel");
    const puToggle = document.getElementById("puToggle");
    const puLabel = document.getElementById("puLabel");
    const tipBox = document.getElementById("tipBox");

    const W = canvas.width, H = canvas.height;

    // --- Sound (tiny UI beeps) ---
    let volume = 0.70;
    vol.addEventListener("input", () => {
      volume = Number(vol.value) / 100;
      volLabel.textContent = Math.round(volume * 100) + "%";
      beep(660, 0.03);
    });

    let powerUpsEnabled = true;
    puToggle.addEventListener("input", () => {
      powerUpsEnabled = (puToggle.value === "1");
      puLabel.textContent = powerUpsEnabled ? "ON" : "OFF";
      // turning off should clear existing power + effects (only power-up behavior)
      if(!powerUpsEnabled){
        clearPower(true);
        p1SpeedTicks = p2SpeedTicks = 0;
        p1ShieldTicks = p2ShieldTicks = 0;
      }
      beep(520, 0.03);
    });

    function beep(freq=440, dur=0.04){
      if(volume <= 0) return;
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if(!AudioCtx) return;
      const ctx = beep._ctx || (beep._ctx = new AudioCtx());
      const o = ctx.createOscillator();
      const gain = ctx.createGain();
      gain.gain.value = Math.max(0.0001, volume * 0.08);
      o.frequency.value = freq;
      o.type = "square";
      o.connect(gain);
      gain.connect(ctx.destination);
      o.start();
      o.stop(ctx.currentTime + dur);
    }

    // ---------- MAP / OBSTACLES (same layout) ----------
    const obs = [
      {x:160,y:160,w:280,h:20},
      {x:520,y:160,w:120,h:20},

      {x:160,y:620,w:120,h:20},
      {x:360,y:620,w:280,h:20},

      {x:160,y:160,w:20,h:220},
      {x:160,y:460,w:20,h:180},

      {x:620,y:160,w:20,h:180},
      {x:620,y:460,w:20,h:180},

      {x:360,y:260,w:30,h:30},
      {x:430,y:260,w:30,h:30},
      {x:360,y:510,w:30,h:30},
      {x:430,y:510,w:30,h:30},

      {x:90,y:280,w:60,h:20},
      {x:90,y:500,w:60,h:20},
      {x:650,y:280,w:60,h:20},
      {x:650,y:500,w:60,h:20},
    ];

    function rectsIntersect(a,b){
      return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + a.h && a.y + a.h > b.y;
    }
    function rectIntersectsAny(r){
      for(const o of obs){
        if(rectsIntersect(r, o)) return true;
      }
      return false;
    }

    function tryMove(x, y, dx, dy, size){
      let nx = x, ny = y;

      nx += dx;
      let testX = {x:nx, y:y, w:size, h:size};
      if(rectIntersectsAny(testX)) nx = x;

      ny += dy;
      let testY = {x:nx, y:ny, w:size, h:size};
      if(rectIntersectsAny(testY)) ny = y;

      nx = Math.max(0, Math.min(W - size, nx));
      ny = Math.max(0, Math.min(H - size, ny));

      return {x:nx, y:ny};
    }
    function slideMove(p, dx, dy, size){
      const nxt = tryMove(p.x, p.y, dx, dy, size);
      p.x = nxt.x; p.y = nxt.y;
    }

    // ---------- GAME STATE ----------
    const base = 20;
    const big  = base + 10;

    const p1 = { x:30,  y:30,  score:0 };    // WASD
    const p2 = { x:740, y:740, score:0 };    // Arrows

    let count = 0; // even => P2 tagger (big), odd => P1 tagger (big)

    // ✅ 30 seconds @ 50 ticks/sec
    const ROUND_TICKS = 1500;
    let roundTicks = ROUND_TICKS;

    const SPEED = 8;
    const TAG_SPEED = SPEED + 1;
    const TAG_REACH = 4;

    let running = false;

    const keys = new Set();
    window.addEventListener("keydown", (e)=>{
      if(e.key === "Escape"){ openMenu(); }
      keys.add(e.key.toLowerCase());
      if(["arrowup","arrowdown","arrowleft","arrowright"," "].includes(e.key.toLowerCase())) e.preventDefault();
    }, {passive:false});
    window.addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()));

    function isP1Tagger(){ return (count % 2 === 1); }
    function sizeForP1(){ return isP1Tagger() ? big : base; }
    function sizeForP2(){ return isP1Tagger() ? base : big; }

    // ---------- POWER UPS ----------
    const POWER_TYPES = ["speed", "shield", "swap", "time"];
    const power = {
      active: false,
      type: null,
      x: 0, y: 0,
      size: 18,
      ttl: 0
    };

    // status timers (ticks)
    let p1SpeedTicks = 0, p2SpeedTicks = 0;
    let p1ShieldTicks = 0, p2ShieldTicks = 0;

    // next spawn counter
    let nextPowerSpawn = randInt(200, 500);

    function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }

    function spawnPower(){
      if(!powerUpsEnabled) return;

      power.type = POWER_TYPES[randInt(0, POWER_TYPES.length-1)];
      power.size = 18;
      power.ttl = randInt(250, 450);

      for(let tries=0; tries<200; tries++){
        const x = randInt(30, W - 30 - power.size);
        const y = randInt(60, H - 30 - power.size);
        const r = {x, y, w: power.size, h: power.size};
        if(!rectIntersectsAny(r)){
          power.x = x; power.y = y;
          power.active = true;
          beep(880, 0.03);
          return;
        }
      }
      // if no valid spot, just delay
      power.active = false;
      nextPowerSpawn = randInt(120, 240);
    }

    function clearPower(resetDelay=false){
      power.active = false;
      power.type = null;
      power.ttl = 0;
      if(resetDelay) nextPowerSpawn = randInt(200, 500);
    }

    function applyPower(playerIndex){
      if(!powerUpsEnabled) return;

      if(power.type === "speed"){
        if(playerIndex === 1) p1SpeedTicks = 300; // 6s
        else p2SpeedTicks = 300;
        beep(990, 0.05);
      }
      else if(power.type === "shield"){
        if(playerIndex === 1) p1ShieldTicks = 250; // 5s
        else p2ShieldTicks = 250;
        beep(660, 0.05);
      }
      else if(power.type === "swap"){
        const tx = p1.x, ty = p1.y;
        p1.x = p2.x; p1.y = p2.y;
        p2.x = tx;   p2.y = ty;
        beep(330, 0.06);
        setTimeout(()=>beep(440, 0.06), 70);
      }
      else if(power.type === "time"){
        roundTicks = Math.min(roundTicks + 250, ROUND_TICKS + 500);
        beep(520, 0.05);
      }

      clearPower(true);
    }

    // ---------- MENU ----------
    function openMenu(){
      running = false;
      menu.style.display = "flex";
      loadTip();
      beep(440, 0.03); setTimeout(()=>beep(660, 0.03), 70);
    }

    function startGame(){
      running = true;
      menu.style.display = "none";
      resetRound(false);
      beep(880, 0.04);
    }

    function resetRound(swapRoles=true){
      p1.x = 30;  p1.y = 30;
      p2.x = 740; p2.y = 740;
      if(swapRoles) count++;
      roundTicks = ROUND_TICKS;

      // clear power + effects each round (ONLY power-up behavior)
      clearPower(true);
      p1SpeedTicks = p2SpeedTicks = 0;
      p1ShieldTicks = p2ShieldTicks = 0;
    }

    playBtn.onclick = startGame;

    resetScoreBtn.onclick = ()=>{
      p1.score = 0; p2.score = 0;
      beep(330, 0.04);
      setTimeout(()=>beep(220, 0.04), 60);
    };

    const tips = [
      "Tip: Use the pillars to force sharp turns.",
      "Tip: Runner should avoid borders; stay near gaps.",
      "Tip: Tagger should cut off lanes, not chase directly.",
      "Tip: Power-ups can change the round fast—watch the map.",
      "Tip: Shield blocks tagging, so chase after it ends.",
    ];
    function loadTip(){
      tipBox.textContent = tips[Math.floor(Math.random()*tips.length)];
    }

    // ---------- LOOP ----------
    let shakeTicks = 0;

    function step(){
      update();
      draw();
      requestAnimationFrame(step);
    }

    function update(){
      if(!running) return;

      // tick effects
      if(p1SpeedTicks > 0) p1SpeedTicks--;
      if(p2SpeedTicks > 0) p2SpeedTicks--;
      if(p1ShieldTicks > 0) p1ShieldTicks--;
      if(p2ShieldTicks > 0) p2ShieldTicks--;

      const p1Tag = isP1Tagger();
      const p1Size = sizeForP1();
      const p2Size = sizeForP2();

      let p1BaseSpeed = (p1Tag ? TAG_SPEED : SPEED);
      let p2BaseSpeed = (p1Tag ? SPEED : TAG_SPEED);

      // speed power-up boost
      if(powerUpsEnabled){
        if(p1SpeedTicks > 0) p1BaseSpeed += 2;
        if(p2SpeedTicks > 0) p2BaseSpeed += 2;
      }

      // move P1
      let p1dx = 0, p1dy = 0;
      if(keys.has("w")) p1dy -= p1BaseSpeed;
      if(keys.has("s")) p1dy += p1BaseSpeed;
      if(keys.has("a")) p1dx -= p1BaseSpeed;
      if(keys.has("d")) p1dx += p1BaseSpeed;
      slideMove(p1, p1dx, p1dy, p1Size);

      // move P2
      let p2dx = 0, p2dy = 0;
      if(keys.has("arrowup")) p2dy -= p2BaseSpeed;
      if(keys.has("arrowdown")) p2dy += p2BaseSpeed;
      if(keys.has("arrowleft")) p2dx -= p2BaseSpeed;
      if(keys.has("arrowright")) p2dx += p2BaseSpeed;
      slideMove(p2, p2dx, p2dy, p2Size);

      // power-up spawn logic (ONLY power-ups)
      if(powerUpsEnabled){
        if(!power.active){
          nextPowerSpawn--;
          if(nextPowerSpawn <= 0) spawnPower();
        } else {
          power.ttl--;
          if(power.ttl <= 0) clearPower(true);
        }
      }

      // ✅ BOTH PLAYERS CAN PICK UP (like before)
      if(powerUpsEnabled && power.active){
        const pr = {x:power.x, y:power.y, w:power.size, h:power.size};
        const hb1 = {x:p1.x, y:p1.y, w:p1Size, h:p1Size};
        const hb2 = {x:p2.x, y:p2.y, w:p2Size, h:p2Size};
        if(rectsIntersect(hb1, pr)) applyPower(1);
        else if(rectsIntersect(hb2, pr)) applyPower(2);
      }

      // timer
      if(roundTicks > 0) roundTicks--;

      // tag check (respect shield if runner has it)
      let hb1 = {x:p1.x, y:p1.y, w:p1Size, h:p1Size};
      let hb2 = {x:p2.x, y:p2.y, w:p2Size, h:p2Size};

      if(p1Tag){
        hb1 = {x:hb1.x - TAG_REACH, y:hb1.y - TAG_REACH, w:hb1.w + TAG_REACH*2, h:hb1.h + TAG_REACH*2};
      } else {
        hb2 = {x:hb2.x - TAG_REACH, y:hb2.y - TAG_REACH, w:hb2.w + TAG_REACH*2, h:hb2.h + TAG_REACH*2};
      }

      const tagged = rectsIntersect(hb1, hb2);

      if(tagged){
        const p1Runner = !p1Tag;
        const p2Runner = p1Tag;

        const runnerShielded =
          (powerUpsEnabled && p1Runner && p1ShieldTicks > 0) ||
          (powerUpsEnabled && p2Runner && p2ShieldTicks > 0);

        if(!runnerShielded){
          if(p1Tag) p1.score++; else p2.score++;
          shakeTicks = 14;
          beep(220, 0.05); setTimeout(()=>beep(110, 0.06), 70);
          resetRound(true);
        } else {
          beep(220, 0.02);
        }
      }
      else if(roundTicks <= 0){
        if(p1Tag) p2.score++; else p1.score++;
        beep(660, 0.04); setTimeout(()=>beep(880, 0.04), 60);
        resetRound(true);
      }
    }

    function draw(){
      // screen shake (pure visual)
      let sx = 0, sy = 0;
      if(shakeTicks > 0){
        shakeTicks--;
        sx = (Math.random()*8 - 4);
        sy = (Math.random()*8 - 4);
      }

      g.setTransform(1,0,0,1,0,0);
      g.clearRect(0,0,W,H);
      g.setTransform(1,0,0,1,sx,sy);

      // grid
      g.strokeStyle = "rgb(25,25,25)";
      for(let x=0;x<W;x+=40){ g.beginPath(); g.moveTo(x,0); g.lineTo(x,H); g.stroke(); }
      for(let y=0;y<H;y+=40){ g.beginPath(); g.moveTo(0,y); g.lineTo(W,y); g.stroke(); }

      // obstacles
      g.fillStyle = "rgb(0,180,255)";
      g.strokeStyle = "white";
      for(const r of obs){
        g.fillRect(r.x,r.y,r.w,r.h);
        g.strokeRect(r.x,r.y,r.w,r.h);
      }

      // power-up draw (ONLY power-ups)
      if(powerUpsEnabled && power.active){
        const cx = power.x + power.size/2;
        const cy = power.y + power.size/2;

        let col = "rgba(255,212,0,.95)";
        let label = "?";
        if(power.type === "speed"){ col = "rgba(0,255,160,.95)"; label = "S"; }
        if(power.type === "shield"){ col = "rgba(180,220,255,.95)"; label = "H"; }
        if(power.type === "swap"){ col = "rgba(255,120,200,.95)"; label = "X"; }
        if(power.type === "time"){ col = "rgba(255,210,120,.95)"; label = "+"; }

        g.fillStyle = col;
        g.beginPath();
        g.arc(cx, cy, power.size/2, 0, Math.PI*2);
        g.fill();

        g.strokeStyle = "white";
        g.stroke();

        g.fillStyle = "black";
        g.font = "16px system-ui, Arial";
        g.fillText(label, power.x + 6, power.y + 14);
      }

      // players
      const p1Tag = isP1Tagger();
      const p1Size = sizeForP1();
      const p2Size = sizeForP2();

      g.fillStyle = p1Tag ? "red" : "white";
      g.fillRect(p1.x, p1.y, p1Size, p1Size);

      g.fillStyle = p1Tag ? "white" : "red";
      g.fillRect(p2.x, p2.y, p2Size, p2Size);

      // shield overlay (pure visual)
      if(powerUpsEnabled && p1ShieldTicks > 0){
        g.strokeStyle = "rgba(180,220,255,.9)";
        g.lineWidth = 3;
        g.strokeRect(p1.x-2, p1.y-2, p1Size+4, p1Size+4);
        g.lineWidth = 1;
      }
      if(powerUpsEnabled && p2ShieldTicks > 0){
        g.strokeStyle = "rgba(180,220,255,.9)";
        g.lineWidth = 3;
        g.strokeRect(p2.x-2, p2.y-2, p2Size+4, p2Size+4);
        g.lineWidth = 1;
      }

      // border
      g.strokeStyle = "#ffd400";
      g.strokeRect(0.5,0.5,W-1,H-1);

      // UI
      const secondsLeft = Math.ceil(roundTicks / 50);

      g.fillStyle = "white";
      g.font = "16px system-ui, Arial";
      g.fillText(`P1: ${p1.score}`, 14, 22);
      g.fillText(`TIME: ${secondsLeft}`, (W/2)-34, 22);
      g.fillText(`P2: ${p2.score}`, W-70, 22);

      g.font = "14px system-ui, Arial";
      g.fillText(p1Tag ? "TAGGER" : "RUNNER", 14, 44);
      g.fillText(p1Tag ? "RUNNER" : "TAGGER", W-82, 44);

      g.font = "12px system-ui, Arial";
      g.fillText(`PU: ${powerUpsEnabled ? "ON" : "OFF"}`, (W/2)-26, 44);

      const p1fx = (powerUpsEnabled && p1SpeedTicks>0 ? "S" : "") + (powerUpsEnabled && p1ShieldTicks>0 ? "H" : "");
      const p2fx = (powerUpsEnabled && p2SpeedTicks>0 ? "S" : "") + (powerUpsEnabled && p2ShieldTicks>0 ? "H" : "");
      g.fillText(`P1 FX: ${p1fx || "-"}`, 14, 62);
      g.fillText(`P2 FX: ${p2fx || "-"}`, W-110, 62);

      g.fillText(`2PlayerTag  |  Dev: Mcant  |  Esc = Menu`, 14, H-12);
    }

    // start loop
    openMenu();
    step();
  </script>
</body>
</html>
